\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{verbatim}
\usepackage{tocbibind}
\usepackage{array}

\definecolor{vert2}{rgb}{0.09,0.30,0.12}
\definecolor{red2}{rgb}{0.43,0.05,0.1}
\definecolor{blue2}{rgb}{0.1,0.05,0.5}

\begin{document}
\title{Projet système : Nachos TP 1}
\author{Martin BAZALGETTE, Antoine BORDE}
\maketitle

\newpage
\tableofcontents
\newpage

\section {Point délicat}

Meme si cette partie 2 étais un peu plus compliqué, les difficulté étais les meme
que pour la partie 1. Elles se situe principalement dans la compréhension du fonctionement
de Nachos et dans la capacité a comprendre l'énnoncer et a suivre le guide proposé sans
partir dans des implémentation compliqué et contre productive. Il faut aussi
bien prendre le temps de réfléchir avant d'implémenté car tout se qui a étais fait dans
cette partie se repercutera sur la suivante (la gestion de plusieur processus).
\newline
Bien évidemment c'est la gestion de plusieur thread simultané qui fut la plus délicate
a implémenté.

\subsection{le multi threading}
\subsubsection{Semaphores et Locks}
La premiere difficulté a été de comprendre le fonctionnement des semaphores et des locks.
Dans un premier temps nous n'arrivions pas a savoir comment implémenter les locks, nous somme
donc partis sur une implementation basique a base de Semaphore. Cela nous a permit d'avancer
rapidement et nous avons naturelement mieux comprit se qu'etais un semaphore.
Nous avons rapidement constater que toute les protections que nous mettions en place ne
devait ne laisser passer qu'un seule thread a la fois. Nous avons comprit a ce moment la qu'un
lock n'est iren d'autre qu'un Semaphore qui ne distribue qu'un seule jeton.
Nous avons donc remplacer les Semaphore par des lock dans notre implementation.

\subsubsection{les piles des threads}

Instancier et éxécuter plusieur thread ne constitue pas de difficulté en soit.
Faire en sorte qu'il ne s'écrase pas les un les autres et un autre probleme.
Nachos ne posséde en effet que peut d'espace allouer a sa pile utilisateur.
On ne peut donc pas raisonablement gerer plus de quatre threads simultanément.
Pour gérer l'allocation des piles des different threads nous avons utilisé la classe
bitmap fournit par Nachos. Nous avons également doté la classe thread d'une nouvelle donné
qui est sa position sur la bitmap. Cela nous a semblé etre la solution la plus simple et
la plus éfficase a condition de prendre garde a respecter le principe d'encapsulation.
Dans un premier, l'orsque me thread principale passe pour la premiere fois dans threadCreate
nous regardont si la bitmap a été instancier. Si ce n'est pas le cas nous l'instancions
et marquon le thread principale a la premiere place.
Aprés cela, chaque thread instancier vont prendre le premier slot libre disponible dans
la bitmap et memorisé le numéro de slot. Puis il appelle AllocateUserStack avec ce
numéro pour récupérer l'espace d'addressage de la pile.
Il libére ensuite ce numéro dans thread exit.

\subsubsection{Protection des threads}

A partir de la il reste encore un probleme majeur a gérer. En effet nous n'avons absolument
pas la main sur l'ordonanceur et nous ne pouvons pas prédire le moment ou les threads
vont essayer de se lancer. Il faut donc mettre en attente les threads qui voudrait
s'allouer une pile avant que des place soit liberer. Au début nous avions décider
d'appeler thread->yield(); qui remet le thread dans la liste d'attente de l'ordonenceur.
Mais nous avons appris que cette technique impliqué de réveillé réguliérement les
thread en attente pour rien se qui gacher du temps d'éxécution.
Nous avons donc fait un gros semaphore qui laisse passé 4 threads(le nombre max de thread
simultané) et dont l'entré se situe au début de startUserThread et la sortie au threadExit.

\subsubsection{Terminaison Automatique}
Un autre gros soucis nous est arrivé l'orsque nous avons voulut implémenter la terminaison
automatique des threads. Le thread principal finit par defaut par l'appelle systeme Exit
qui interront la machine.
Nous avons envisager deux solution:
La premiere consistait a utiliser une variable pour conté le nombre de threads utilisateur actif
et d'appeler thread->yield tant que celle ci n'est pas a 0 pour faire attentre le thread principal
au niveau de l'appel systeme Exit. Nous avons décider d'écarter cette solution car yield()
consomme du temps(meme si ce n'est que sur le thread principale)
La deuxieme était d'appeler ThreadExit dans Exit et d'utiliser la bitmap pour appeler interrupt-Halt()
lorsque celle ci est vide.


\section{Limitation}

Cette partie du rapport est encore une fois la plus difficile a rédiger. En effet
meme si notre compréhension global du fonctionnement de Nachos a bien évoluer dans
cette partie, il reste trés difficile de savoir ou se situe les défaut de notre
implémentation (dans la mesure ou nos test fonctionne). D'autant qu'il s'agit surtout
de savoir si nos choix d'implémentation sont les bons pour la suite du projet (la gestion
de plusieur processus) et que cela reste trés difficile a certifier.
\newline
\newline
Dans l'ensemble nous dirions que notre implementation se veut simple et fonctionnel.
Nous penssons etre allé a l'éssentiel sans nous compliqué la vie et avoir réussi a faire
un code qui fonctionne en collant au plus prés des conseille du tp.
Nous n'avons pas réperer de bug, les tests éffectuer termine tous convenablement. Nous gerons plusieur
cas de figure notament ceux ou le thread principale appelle un thread qui appelle un thread
etc...
\newline
\newline
Nous avons quand meme une petite fuite memoire que nous n'arrivons pas a
supprimer.(1 block possiblement perdu d'aprés valgrind)
Mais notre inquiétude majeur est de savoir si nous avons fait les bon choix d'impélmentation
pour la suite du tp. En effet nous avons énormément centralisé le fonctionnement des
threads et de tout se qui les entoures dans le fichier userthread.cc les fonction do_threadExit
do_threadCreate et StartUserThread.
De l'instanciation et l'utilisation des lock et des Semaphore a la bitmap en passant par
l'interruption meme de la machine l'orsque qu'il ne reste plus aucun thread a éxécuter. Tout
ce gere dans userthread.cc.
Cependant nous relativisons la gravité d'une erreur a ce niveau la, car nous penssons que si
des modification doive etre faite plus tard il s'agira plus de déplacer l'implementation éxistante que de
la modifier se qui ne représente pas la mème quantité de travail.






\end{document}
\grid
