\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{verbatim}
\usepackage{tocbibind}
\usepackage{array}

\definecolor{vert2}{rgb}{0.09,0.30,0.12}
\definecolor{red2}{rgb}{0.43,0.05,0.1}
\definecolor{blue2}{rgb}{0.1,0.05,0.5}

\begin{document}
\title{Projet système : Nachos TP 1}
\author{Martin BAZALGETTE, Antoine BORDE}
\maketitle

\newpage
\tableofcontents
\newpage

\section {Points délicats}

Meme si cette partie 2 était un peu plus compliquée, les difficultés étaient les mêmes
que pour la partie 1. Elles se situent principalement dans la compréhension du fonctionement
de Nachos et dans la capacité à comprendre l'énnoncé et à suivre le guide proposé sans
partir dans des implémentations compliquées et contre productives. Il faut aussi
bien prendre le temps de réfléchir avant d'implémenter car tout ce qui a été fait dans
cette partie se repercutera sur la suivante (la gestion de plusieurs processus).
\newline
Bien évidemment c'est la gestion de plusieurs threads simultanés qui fut la plus délicate
à implémenter.

\subsection{Le multithreading}
\subsubsection{Sémaphores et Locks}
La première difficulté a été de comprendre le fonctionnement des sémaphores et des locks.
Dans un premier temps nous n'arrivions pas a savoir comment implémenter les locks, nous somme
donc partis sur une implementation basique à base de sémaphores. Cela nous a permi d'avancer
rapidement et nous avons naturellement mieux compris ce qu'etait un sémaphore.
Nous avons rapidement constaté que toutes les protections que nous mettions en place ne
devaient laisser passer qu'un seul thread à la fois. Nous avons compris à ce moment là qu'un
lock n'est rien d'autre qu'un sémaphore qui ne distribue qu'un seul jeton.
Nous avons donc remplacé les sémaphores par des locks dans notre implementation.

\subsubsection{Les piles des threads}

Instancier et éxécuter plusieurs threads ne constitue pas de difficulté en soit.
Faire en sorte qu'ils ne s'écrasent pas les un les autres est un autre problème.
Nachos ne possède en effet que peu d'espace alloué à sa pile utilisateur.
On ne peut donc pas raisonnablement gérer plus de quatre threads simultanément.
Pour gérer l'allocation des piles des differents threads nous avons utilisé la classe
bitmap fournie par Nachos. Nous avons également doté la classe thread d'une nouvelle donnée
qui est sa position sur la bitmap. Celà nous a semblé être la solution la plus simple et
la plus efficace à condition de prendre garde à respecter le principe d'encapsulation.
Dans un premier temps, lorsque le thread principal passe pour la première fois dans threadCreate
nous regardons si la bitmap a été instanciée. Si ce n'est pas le cas nous l'instancions
et marquons le thread principal à la première place.
Après celà, chaque thread instancié va prendre le premier slot libre disponible dans
la bitmap et memoriser le numéro de ce slot. Puis il appelle AllocateUserStack avec ce
numéro pour récupérer l'espace d'adressage de la pile.
Il libère ensuite ce numéro dans ThreadExit.

\subsubsection{Protection des threads}

A partir de là, il reste encore un problème majeur à gérer. En effet nous n'avons absolument
pas la main sur l'ordonnanceur et nous ne pouvons pas prédire le moment où les threads
vont essayer de se lancer. Il faut donc mettre en attente les threads qui voudraient
s'allouer une pile avant que des places soit liberées. Au début nous avions décidé
d'appeler thread->yield() qui remet le thread dans la liste d'attente de l'ordonnanceur.
Mais nous avons appris que cette technique impliquait de réveiller régulièrement les
threads en attente pour rien, ce qui gachait du temps d'éxécution.
Nous avons donc créé un gros sémaphore qui laisse passer 4 threads(le nombre max de thread
simultanés) et dont l'entrée se situe au début de startUserThread, et la sortie dans do_threadExit.

\subsubsection{Terminaison automatique}
Un autre gros soucis nous est arrivé lorsque nous avons voulu implémenter la terminaison
automatique des threads. Le thread principal finit par defaut par l'appel système Exit
qui interrompt la machine.
Nous avons envisagé deux solutions :
La première consistait à utiliser une variable pour compter le nombre de threads utilisateur actifs
et d'appeler thread->yield() tant que celle-ci n'est pas à 0 pour faire attendre le thread principal
au niveau de l'appel systeme Exit. Nous avons décidé d'écarter cette solution car yield()
consomme du temps (même si ce n'est que sur le thread principal)
La deuxième était d'appeler ThreadExit dans Exit et d'utiliser la bitmap pour appeler interrupt-Halt()
lorsque celle-ci est vide.


\section{Limitations}

Cette partie du rapport est encore une fois la plus difficile à rédiger. En effet
meme si notre compréhension globale du fonctionnement de Nachos a bien évolué dans
cette partie, il reste très difficile de savoir où se situe les défauts de notre
implémentation (dans la mesure ou nos test fonctionnent). D'autant qu'il s'agit surtout
de savoir si nos choix d'implémentation sont les bons pour la suite du projet (la gestion
de plusieurs processus) et que cela reste très difficile à certifier.
\newline
\newline
Dans l'ensemble nous dirions que notre implementation se veut simple et fonctionnelle.
Nous pensons être allés à l'éssentiel sans nous compliquer la vie et avoir réussi à faire
un code qui fonctionne en collant au plus près des conseils du tp.
Nous n'avons pas réperé de bug, les tests éffectués terminent tous convenablement. Nous gerons plusieurs
cas de figure notamment ceux où le thread principal appelle un thread qui appelle un thread.
\newline
\newline
Nous avons néanmoins une petite fuite mémoire que nous n'arrivons pas a
supprimer (un block possiblement perdu d'aprés valgrind).
Cependant notre inquiétude majeure est de savoir si nous avons fait les bons choix d'impélmentation
pour la suite du TP. En effet nous avons énormément centralisé le fonctionnement des
threads et de tout ce qui les entoure dans les fonction do_threadExit
do_threadCreate et StartUserThread du fichier userthread.cc.
De l'instanciation et l'utilisation des locks et des sémaphores à la bitmap en passant par
l'interruption même de la machine lorsqu'il ne reste plus aucun thread a éxécuter. Tout
se gere dans userthread.cc.
Nous relativisons malgré tout la gravité d'une erreur à ce niveau la, car nous pensons que si
des modifications doivent être faites plus tard il s'agira plus de déplacer l'implementation existante que de
la modifier, ce qui ne représente pas la même quantité de travail.






\end{document}
\grid
