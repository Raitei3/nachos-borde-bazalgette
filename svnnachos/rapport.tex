\documentclass[10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{verbatim}
\usepackage{tocbibind}
\usepackage{array}

\definecolor{vert2}{rgb}{0.09,0.30,0.12}
\definecolor{red2}{rgb}{0.43,0.05,0.1}
\definecolor{blue2}{rgb}{0.1,0.05,0.5}

\begin{document}
\title{Projet système : Nachos TP 1}
\author{Martin BAZALGETTE, Antoine BORDE}
\maketitle

\newpage
\tableofcontents
\newpage

\section {Point délicat}

Meme si cette partie 2 étais un peu plus compliqué, les difficulté étais les meme
que pour la partie 1. Elles se situe principalement dans la compréhension du fonctionement
de Nachos et dans la capacité a comprendre l'énnoncer et a suivre le guide proposé sans
partir dans des implémentation compliqué et contre productive. \newline Il faut aussi
bien prendre le temps de réfléchir avant d'implémenté car tout se qui a étais fait dans
cette partie se repercutera sur la suivante (la gestion de plusieur processus).
\newline
Bien évidemment c'est la gestion de plusieur thread simultané qui fut la plus délicate
a implémenté.

\subsection{le multi threading}
\subsubsection{Semaphores et Locks}
La premiere difficulté a été de comprendre le fonctionnement des semaphores et des locks.
Dans un premier temps nous n'arrivions pas a savoir comment implémenter les locks, nous somme
donc partis sur une implementation basique a base de Semaphore. Cela nous a permit d'avancer
rapidement et nous avons naturelement mieux comprit se qu'etais un semaphore.
\newline
Nous avons rapidement constater que presque toute les protections que nous mettions en place ne
devait ne laisser passer qu'un seule thread a la fois. Nous avons comprit a ce moment la qu'un
lock n'est iren d'autre qu'un Semaphore qui ne distribue qu'un seule jeton.
Nous avons donc remplacer les Semaphore par des lock dans notre implementation.

\subsubsection{les piles des threads}

Instancier et éxécuter plusieur thread ne constitue pas de difficulté en soit.
Faire en sorte qu'il ne s'écrase pas les un les autres et un autre probleme.
Nachos ne posséde en effet que peut d'espace allouer a sa pile utilisateur.
On ne peut donc pas raisonablement gerer plus de quatre threads simultanément.
\newline
Pour gérer l'allocation des piles des different threads nous avons utilisé la classe
bitmap fournit par Nachos. Nous avons également doté la classe thread d'une nouvelle donné
qui est sa position sur la bitmap. Cela nous a semblé etre la solution la plus simple et
la plus éfficase a condition de prendre garde a respecter le principe d'encapsulation.
Dans un premier, l'orsque le thread principale passe pour la premiere fois dans threadCreate
nous regardont si la bitmap a été instancier. Si ce n'est pas le cas nous l'instancions
et marquon le thread principale a la premiere place.
\newline
Aprés cela, chaque thread instancier vont prendre le premier slot libre disponible dans
la bitmap et memorisé le numéro de slot. Puis il appelle AllocateUserStack avec ce
numéro pour récupérer l'espace d'addressage de la pile.
Il libére ensuite ce numéro dans thread exit.

\subsubsection{Protection des threads}

A partir de la il reste encore un probleme majeur a gérer. En effet nous n'avons absolument
pas la main sur l'ordonanceur et nous ne pouvons pas prédire le moment ou les threads
vont essayer de se lancer. Il faut donc mettre en attente les threads qui voudrait
s'allouer une pile avant que des place soit liberer.
\newline
Au début nous avions décider
d'appeler thread->yield(); qui remet le thread dans la liste d'attente de l'ordonenceur.
Mais nous avons appris que cette technique impliqué de réveillé réguliérement les
thread en attente pour rien se qui gacher du temps d'éxécution.
\newline
Nous avons donc fait un gros semaphore qui laisse passé 4 threads(le nombre max de thread
simultané) et dont l'entré se situe au début de startUserThread et la sortie au threadExit.

\subsubsection{Terminaison Automatique}
Un autre gros soucis nous est arrivé l'orsque nous avons voulut implémenter la terminaison
automatique des threads. Le thread principal finit par defaut par l'appelle systeme Exit
qui interront la machine.
Nous avons envisager plusieur solution:
\newline
\newline
La premiere était d'appeler ThreadExit dans Exit et d'utiliser la bitmap pour appeler interrupt-Halt()
lorsque celle ci est vide. Cette solution avait pour avantage de ne pas faire attendre le thread principale
pour rien mais elle changer trop radicalement le fonctionnement d'Exit(). Nous ne pouvions notamment
plus récupérer la valeur de retour.
\newline
La deuxieme consistait a utiliser une variable pour conté le nombre de threads utilisateur actif
et d'appeler thread->yield tant que celle ci n'est pas a 0 pour faire attentre le thread principal
au niveau de l'appel systeme Exit. Cette solution fait perdre un peu de temps d'éxécution (mais cela reste restraint
ai thread principale). Et elle permet surtout de conserver un comportement normal de l'appel system exit.
\newline
Nous avons aussi imaginer récupérer la valeur de retour du thread principale dans Exit et la stocker jusqua
la destruction du dernier thread qui se chargera de donner la valeur de retour.
\newline
\newline
Nous avons dans un premier temps choisit de prendre la deuxieme solution car cette derniere a été
recommander en cour. Mais cette implementation est façilement modifiable. Nous en parlerons sans doute
au prochain td ou l'ors de la correction

\section{Limitation}

Cette partie du rapport est encore une fois la plus difficile a rédiger. En effet
meme si notre compréhension global du fonctionnement de Nachos a bien évoluer dans
cette partie, il reste trés difficile de savoir ou se situe les défaut de notre
implémentation (dans la mesure ou nos test fonctionne). D'autant qu'il s'agit surtout
de savoir si nos choizx d'implémentation sont les bons pour la suite du projet (la gestion
de plusieur processus) et que cela reste trés difficile a certifier.
\newline
\newline
Dans l'ensemble nous dirions que notre implementation se veut simple et fonctionnel.
Nous penssons etre allé a l'éssentiel sans nous compliqué la vie et avoir réussi a faire
un code qui fonctionne en collant au plus prés des conseille du tp.
Nous n'avons pas réperer de bug, les tests éffectuer termine tous convenablement. Nous gerons plusieur
cas de figure notament ceux ou le thread principale appelle un thread qui appelle un thread
etc...
\newline
\newline
Nous avons quand meme une petite fuite memoire que nous n'arrivons pas a
supprimer.(1 block possiblement perdu d'aprés valgrind)
Mais notre inquiétude majeur est de savoir si nous avons fait les bon choix d'impélmentation
pour la suite du tp. En effet nous avons énormément centralisé le fonctionnement des
threads et de tout se qui les entoures dans le fichier userthread.cc les fonction do\_threadExit
do\_threadCreate et StartUserThread.
De l'instanciation et l'utilisation des lock et des Semaphore a la bitmap. Presque tout
ce gere dans userthread.cc.
\newline
\newline
Cependant nous relativisons la gravité d'une erreur a ce niveau la, car nous penssons que si
des modification doive etre faite plus tard il s'agira plus de déplacer l'implementation éxistante
(qui a notre avis est bonne) que de la modifier se qui ne représente pas la mème quantité de travail.






\end{document}
\grid
